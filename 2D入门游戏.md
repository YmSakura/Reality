# 2D游戏入门

## Session01：安装软件&导入素材

跳过了

## Session02：编辑素材& Tilemap

### 导入背景图

直接将背景图片拖到Hierarchy窗口，默认坐标就是（0，0）

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211020150727289.png" alt="image-20211020150727289" style="zoom:67%;" />

导入素材发现这个背景的pixels per unit是100，也就是每个小格子包含100*100个像素点

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211020150825467.png" alt="image-20211020150825467" style="zoom:67%;" />

这样图片导入进去会非常小，就像这样，因为back是384*240的，所以可以看到宽度为3.8个格，高度为2.4个格

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211020150859672.png" alt="image-20211020150859672" style="zoom:67%;" />

我们把它修改为16，也就是每个单元格有16*16的像素，就能正常显示了

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211020150949861.png" alt="image-20211020150949861" style="zoom:67%;" />

### 创建场景

2D游戏中有一个非常常用的功能，叫做TileMap（瓦片地图），我们可以直接在Hierachy中创建它

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211020151628921.png" alt="image-20211020151628921" style="zoom:67%;" />

可以看到屏幕中出现了很多网格，我们就是要在这些网格上画东西，为了方便，我们先将back隐藏：

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211020151809894.png" alt="image-20211020151809894" style="zoom:67%;" />

要在这些“瓦片”上画东西，需要使用Tile Palette，可以在window->2d找到

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211026110548998.png" alt="image-20211026110548998" style="zoom:67%;" />

打开之后就是这样的：

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211020155541223.png" alt="image-20211020155541223" style="zoom:67%;" />

这里有两张图片，一个是已经“切好的”，一个是没有切过的，这里演示一下具体是怎么切的

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211020155647213.png" alt="image-20211020155647213" style="zoom:67%;" />

选中tileset，在inspector窗口里修改以下选项

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211020155835060.png" alt="image-20211020155835060" style="zoom:67%;" />

### Sprite介绍

Sprite直接翻译过来是精灵，在游戏开发中，可以独立于背景独立移动的二维位图被称为Sprite，它们可以有独立的屏幕坐标、帧率、周期等等，在最终渲染时，它们会与背景等一起被合成为你看到的每一帧画面。

对于早期的视频游戏，这种合成并非像现在用GPU来做，而是通过电路、显像管等硬件在显示器逐行扫描时实现的。由于这些可被移动的对象（movable objects)并不属于显存(framebuffer)中的位图数据，而像是“浮”在之上的，就像鬼或者小妖精(Sprite)一样，因此得名。

随着CG的发展，Sprite的含义也得到拓展，只要是用于合成的相对独立的二维位图，都可以被称作Sprite，比如Flash等游戏引擎中就有使用Sprite这样的概念。另外，游戏中的Sprite通常都有自己的状态、动画，所以美术师和程序员会通过SpriteSheet这样的素材进行合作。

![SpriteSheet](https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/SpriteSheet.jpg)

通过导出导入SpriteSheet的各种坐标信息，程序员就可以直接获得设计师设计好的动画效果，并且直接运用在游戏开发中。

这种做法被前端工程师以节省网络I/O（即HTTP请求线头阻塞）的目的借鉴去之后，就沿用了Sprite这个名字，配合CSS background-position，便可以做到在一张大图中切出各个小图的目的。

### 切割图片

调整好参数后，点击Sprite Editor

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211020161959877.png" alt="image-20211020161959877" style="zoom:67%;" />

将Type改为Grid By Cell Size，Pixel Size改为16*16（因为之前设置的一个单元格16个元素，这样设置之后就是一个单元格一个图片），点击Apply，就切割好了

### 绘制场景

把切割好的图片拖到Tile Palette，就可以进行绘制了

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211020162230124.png" alt="image-20211020162230124" style="zoom:67%;" />



## Session03：图层layer&角色建立

### 调整图层顺序

我们铺好场景之后把back弄回来，发现它可能遮挡住地图了，这就是图层没设置顺序的问题，我们要对图层进行排序

注意这里上面也有一个Layer，这是属于图层分类，而我们要修改的是下面的Sorting Layer

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211021105050327.png" alt="image-20211021105050327" style="zoom:67%;" />

新添加两个Sorting Layer

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211021105612784.png" alt="image-20211021105612784" style="zoom: 67%;" />

然后分别为back和Tilemap选择对应图层，注意这里排列越靠下的图层显示在越前面。

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211021105658867.png" alt="image-20211021105658867" style="zoom:67%;" />

还有一种方式是，将它们设置为同一图层，然后调整Order in Layer的大小，越大的显示在越前面。

### 创建角色

将角色拖入到场景中有很多方法：

* 可以直接将素材拖到Scene窗口

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211021110529976.png" alt="image-20211021110529976" style="zoom:67%;" />

别忘了将素材的pixels per unit设置为16，还有设置Layer的顺序。

* 还有一种方法是，在Hierarchy窗口中创建一个Sprite

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211021111018953.png" alt="image-20211021111018953" style="zoom:67%;" />

把人物拖到Sprite Renderer的Sprite里

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211021111058432.png" alt="image-20211021111058432" style="zoom:67%;" />

同样别忘了设置Sorting Layer。

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211021111201908.png" alt="image-20211021111201908" style="zoom:67%;" />

这样就也能够显示人物了。

### 添加组件

我们当前的人物是不会动的，需要为它添加各种组件，使它符合真实的物理效果和其他效果。

首先添加一个Rigidbody 2D组件

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211021112037652.png" alt="image-20211021112037652" style="zoom:67%;" />

可以看到很多参数，比如Mass（阻力）、Gravity Scale（重力）等等

添加之后我们点击play播放场景，发现人物直接掉下去了，这是因为没有碰撞体的原因，需要为想要发生碰撞的物体添加collider组件。

添加collider之后，发现人物周围有一圈绿框，这就是它碰撞的范围，我们可以手动调整一下，将它缩小，注意在新版unity要选中Edit Collider，要不然缩放的是人物的大小。

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211021112459546.png" alt="image-20211021112459546" style="zoom:67%;" />

再次点击Play，人物就可以站在地面上了。

## Session04：角色移动

本节课我们要为角色添加一个脚本，来控制角色的移动，直接看代码就能看懂：

```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class PlayerController : MonoBehaviour
{
    public Rigidbody2D rb;
    public float speed = 10.0f;


    // Start is called before the first frame update
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        Movement();
    }

    void Movement()
    {
        float moveSpeed = Input.GetAxis("Horizontal");
        if (moveSpeed != 0)
        {
            rb.velocity = new Vector2(moveSpeed * speed, rb.velocity.y);
        }
    }
}
```

首先声明刚体组件，然后回到Unity把自身的刚体组件拖进去

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211021122852507.png" alt="image-20211021122852507" style="zoom:67%;" />

声明速度，可以设置初始值，也可以随后在Unity中调整，最终效果以Unity中的设置为准。

然后写一个移动的函数Movement，放到Update里面

逻辑：获取水平轴的值，将值传给一个变量，如果不为0的话就证明按下了按键，那就将rb的velocity也就是速度赋值为一个Vector，y方向不需要移动，所以y不变，x方向设置为moveSpeed * speed，也就是用基础速度值去乘获取到的水平轴参数（这个参数会在-1和1之间变化）。

回到Unity，点击Play，人物可以移动了，但发现人物会乱飘，这是因为没有固定z轴的旋转，可以在人物的Rigidbody组件里找到Constraints

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211021123553875.png" alt="image-20211021123553875" style="zoom:67%;" />

在2D游戏中，一般Object的z轴位置一般都是0，摄像机则为负值

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211021123911503.png" alt="image-20211021123911503" style="zoom:67%;" />

这样看一下就直观了，固定z轴的rotation，也就是不让它在2D平面内旋转。

这样人物就不会乱飘了，设置完成。

## Session05：角色方向&跳跃

实现了人物转向和跳跃：

```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class PlayerController : MonoBehaviour
{
    public float speed = 400.0f;
    public float jumpforce = 400.0f;

    // Update is called once per frame
    //不同电脑性能不同，每分钟调用Update的次数就不同
    void Update()
    {
        Movement();
    }

    void Movement()
    {
        //GetAxisRaw ：直接返回-1 0 1，没有过渡值
        float faceDirection = Input.GetAxisRaw("Horizontal");
        
        //角色移动，fixedDeltaTime的值是0.02，乘以这个值是为了平衡不同电脑的性能，使人物速度一样
        if (horizontalAxis != 0)
        {
            rb.velocity = new Vector2(horizontalAxis * speed * Time.fixedDeltaTime, rb.velocity.y);
        }
        
        //人物转向
        if(faceDirection != 0)
        {
            transform.localScale = new Vector3(faceDirection, 1, 1);
        }
        
        if (Input.GetButtonDown("Jump"))
        {
            rb.velocity = new Vector2(rb.velocity.x, jumpforce * Time.fixedDeltaTime);
        }
    }
}
```

**有关Input的操作不要放在FixedUpdate里面，可能会漏掉很多按键触发。**

## Session06：动画效果Animation

### 添加动画效果

这节课我们来为人物添加动画效果

先为人物创建一个Animator组件，并创建一个Animator Controller，将它拖到Animator组件的对应位置。

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211022144048527.png" alt="image-20211022144048527" style="zoom:67%;" />

然后来创建具体的动画，在Window->Animation下找到Animation并打开：

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211022144157499.png" alt="image-20211022144157499" style="zoom:67%;" />

这是一个和flash一样的东西，点击新建一个clip，叫做idle，作为闲置状态的动画

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211022144249937.png" alt="image-20211022144249937" style="zoom:67%;" />

然后将素材中的图片拖到右边的时间轴那里，此时点击播放，会发现人物的运动太快了，有两种方法可以调节速度，一种是选中所有帧，将它拉长，另一种是直接修改samples的值，也就是取样的频率，这里选择第二种方式，将samples修改为10

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211022144513410.png" alt="image-20211022144513410" style="zoom:67%;" />

如果发现没有samples的可以点击右上角的三个点来添加。

这样动画速度就正常了。

按照同样的方法为人物添加run的动画。

### 设置动画切换

我们现在有两种动画状态，idle和run，需要在这两种状态之间切换，有很多方法可以实现，这里我们选择通过人物“速度”的判断来实现

Window->Animation下找到Animator并打开

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211022145532310.png" alt="image-20211022145532310" style="zoom:67%;" />

这里已经有我们添加的两个动画idle和run，分别选择它们，右键选择make transition，也就是创建过渡

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211022145655557.png" alt="image-20211022145655557" style="zoom:67%;" />

在左上角的parameters那里添加一个float类型的参数running

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211022141535245.png" alt="image-20211022141535245" style="zoom:67%;" />

选中idel->run的transition箭头，在右侧的Inspector修改参数，不需要exit time，取消勾选，也不需要transition duration也就是过渡时间，我们希望它直接切换状态，然后新增一个condition，当running值大于0.1时切换动画为run。

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211022141632245.png" alt="image-20211022141632245" style="zoom:67%;" />

同样对run->idle也进行相应的修改

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211022141820129.png" alt="image-20211022141820129" style="zoom:67%;" />

好了，那么怎么将running参数对应到人物的速度呢？这就需要在PlayController中设置Animator的相关参数了。

```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class PlayerController : MonoBehaviour
{
    public Animator animator;

    // Update is called once per frame
    void Update()
    {
        Movement();
    }

    void Movement()
    {
		//...省略
        
        //角色移动
        if (horizontalAxis != 0)
        {
            rb.velocity = new Vector2(horizontalAxis * speed * Time.fixedDeltaTime, rb.velocity.y);
            //控制运动动画
            animator.SetFloat("running", Mathf.Abs(faceDirection));
        }
        
		//...省略
    }
}
```

获得Animator组件，设置float类型的参数"running"的值（可以选择通过id或name的方式来获取变量）为faceDirection的绝对值（也就是只有0和1），当0时人物处于idle状态，当1时run。

## Session07：跳跃动画 LayerMask

### 添加动画、设置转换条件

这节课我们来为人物添加跳跃动画。

按照上节课的方法，添加jump和fall的动画到Player，然后回到Animator，添加这样的transition关系

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211022153552601.png" alt="image-20211022153552601" style="zoom:67%;" />

并设置condition，添加两个bool类型的参数，分别对应jumping、falling，处于idle和run的状态时如果jumping为true就切换为jump动画，处于jump状态时如果falling为true并且jumping为false就切换为fall动画，处于fall状态时如果falling为false就切换为idle动画。

### 写代码

```c#
void SwitchAnimation()
    {
        //正在跳跃
        if (animator.GetBool("jumping"))
        {
            //y轴向上的速度为0，开始下落
            if(rb.velocity.y < 0)
            {
                animator.SetBool("jumping", false);
                animator.SetBool("falling", true);
            }
        }

        //正在下落
        if (animator.GetBool("falling"))
        {
            if(rb.velocity.y == 0)
            {
                animator.SetBool("falling", false);
            }
        }
    }
```

这样就可以实现基本的跳跃和下落动画了。

但注意到`if(rb.velocity.y == 0)`这个判断语句，当人物处于斜坡上时y方向的速度也不为0，可能会一直处于falling状态。

所以这里要用到LayerMask

### LayerMask

我们为人物脚本新添加一个组件`public LayerMask ground;`

因为我们想要检测是否碰撞到地面，所以我们为Tilemap添加一个Layer叫Ground，并为它选择：

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211026114249712.png" alt="image-20211026114249712" style="zoom:67%;" />

然后回到Player，将刚才声明的LayerMask选择为Ground：

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211026114351354.png" alt="image-20211026114351354" style="zoom:67%;" />

完善代码：

因为要检测碰撞，所以还需要一个collider组件

```c#
public class PlayerController : MonoBehaviour
{

    public LayerMask ground;
    public Collider2D coll;

    // Update is called once per frame
    void Update()
    {
        Movement();
        SwitchAnimation();
    }

    void SwitchAnimation()
    {
        
        //正在跳跃
        if (animator.GetBool("jumping"))
        {
            //y轴速度消失，开始下落
            if(rb.velocity.y < 0)
            {
                animator.SetBool("jumping", false);
                animator.SetBool("falling", true);
            }
        }

        //正在下落
        if (animator.GetBool("falling"))
        {
            if(coll.IsTouchingLayers(ground))
            {
                animator.SetBool("falling", false);
            }
        }
    }
}
```

## Session08：修复移动错误

现在游戏中有一个小bug，就是人物在移动的过程中可能会卡住动不了，这是因为人物的碰撞体是方形的，而Tilemap的碰撞体也是方形的，方形和方形之间可能会有小缝隙，会被卡住，那么我们就可以将人物的碰撞体修改成其他形状的，这里我们为其新添加一个圆形碰撞体，组成两个碰撞体，为什么需要两个呢，老师说后面会用到，这里先不提，调整好碰撞体位置之后我们把圆形的collider拖到playController中，作为碰撞检测的collider，再次运行游戏，问题已经解决了！

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211026131835137.png" alt="image-20211026131835137" style="zoom:67%;" />

这里还可以更改一下代码，将一些需要本身组件的组件声明为pirvate，并在Start中初始化：

```c#
public class PlayerController : MonoBehaviour
{
    [SerializeField]private Rigidbody2D rb;
    private Animator animator;

    public Collider2D coll;
    public LayerMask ground;


    // Start is called before the first frame update
    void Start()
    {
        rb = GetComponent<Rigidbody2D>();
        animator = GetComponent<Animator>();
    }
}
```

这样我们就不用手动拖动组件了，游戏开始时就会自动获取自身的相应组件。

## Session09：镜头移动 Cinemachine

要想实现镜头移动，有一个很简单的做法，就是让摄像机的坐标与人物的坐标保持一致，因为y轴方向不需要移动，所以y轴和z轴坐标保持不变

```c#
public class CameraController : MonoBehaviour
{
    public Transform player;

    // Start is called before the first frame update
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        transform.position = new Vector3(player.position.x, 0, -10f);
    }
}
```

但是这样做有一个坏处就是可能会跳出背景图片的边界，那么我们可以安装一个很好用的package来实现镜头跟随效果，就是Cinemachine，从Asset Store安装后，就可以在屏幕上方的tool bar里找到，点击创建一个2D的相机：

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211026225211315.png" alt="image-20211026225211315" style="zoom:67%;" />

将人物拖到这里：

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211026230405231.png" alt="image-20211026230405231" style="zoom:67%;" />

还可以通过设置以下这些参数调整摄像机的跟随情况：

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211026230548431.png" alt="image-20211026230548431" style="zoom:67%;" />

ScreenX和ScreenY即摄像机的位置，默认为0.5*0.5，在屏幕的正中间，Dead Zone表示盲区，人物在这个范围内移动不会触发摄像机的跟随。

用了这个组件之后摄像机的跟随变得更“人性化”了，但依然没有解决跳出背景图片边界的情况。

我们需要为Cinemachine相机再添加一个extensions：confiner

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211026232326370.png" alt="image-20211026232326370" style="zoom:67%;" />

并为背景图片添加一个polygon（多边形）的collider，将其拖到confiner里面，这个碰撞体就是镜头跟随的范围。

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211026232359100.png" alt="image-20211026232359100" style="zoom:67%;" />

注意要勾选is trigger（触发器），要不然它会作为碰撞体把人物弹飞。

## Session10：物品收集&Prefabs

### 创建物体

这节课我们开始放置物品到地图中，角色吃到了可以加分。

利用前面创建人物的方法，将素材包里的樱桃创建到场景中（创建一个2D精灵然后把图片拖到sprite），然后为其添加一个animator组件，这个组件需要一个animator controller，那就再创建一个，然后就可以在Animation窗口创建动画了，将Cherry的系列图片拖过去，设置Samples，就OK了。

因为人物要能吃到樱桃，所以需要为它创建一个collider，调整碰撞体大小，并勾选is trigger，然后写代码：

```c#
	public int score;

	private void OnTriggerEnter2D(Collider2D collision)
    {
        if (collision.tag == "Collection")
        {
            Destroy(collision.gameObject);
            score++;
        }
    }
```

这里要为Cherry创建一个标签，用于判断碰撞到的物体类型。

### Prefabs

因为我们需要很多樱桃，并且要保证它们的参数都相同，这里我们就可以用到prefabs即预制体，创建一个专门的文件夹，然后将hierachy窗口中的物体拖到文件夹里，就会自动成为prefabs：

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211029183402545.png" alt="image-20211029183402545" style="zoom:67%;" />

在这里调整参数，可以应用到场景中所有以prefabs为原型的物体。

### 丰富场景

为了场景中能够显示更多的物体，我们可以创建很多Layer，通过Layer的顺序调整它们的显示顺序。同一Layer可以调整Order in Layer的大小来调整显示顺序。

## Session11：物理材质&空中跳跃

### 物理材质

现在有一个问题是人物碰到比较大的物体时，如果一直按住方向键，就会卡在那个物体上面，不会下落，为了解决这个问题，我们需要为人物的collider添加一个材质：

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211030114803851.png" alt="image-20211030114803851" style="zoom:67%;" />

将Friction也就是摩擦力调整为0.01，这里不调成0的原因是，如果人物站在斜坡上会慢慢滑下去。

### 限制跳跃次数

只需要在跳跃的时候添加一个判断条件就可以了，也就是只有在地面上才可以跳跃

```c#
		if (Input.GetButtonDown("Jump") && coll.IsTouchingLayers(ground))
        {
            //通过修改速度来实现跳跃，x不变，y变大
            rb.velocity = new Vector2(rb.velocity.x, jumpforce * Time.fixedDeltaTime);
            animator.SetBool("jumping", true);
        }
```

## Session12：UI入门

如果想在游戏界面显示得分的话，就要使用基本的UI功能了：

所有的UI功能都是基于Canvas的，所以我们需要先创建一个Canvas画布：

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211030133202662.png" alt="image-20211030133202662" style="zoom:67%;" />

然后创建两个Text：Cherry和Numbers，分别修改文本内容，并调整它们的位置：

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211030133342912.png" alt="image-20211030133342912" style="zoom:67%;" />

但是此时进入游戏之后，会发现随着窗口的调整Text的位置也在变化，所以这里要用到锚点的功能：

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211030133458046.png" alt="image-20211030133458046" style="zoom:67%;" />

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211030133506907.png" alt="image-20211030133506907" style="zoom:67%;" />

我们想要Text永远固定在左上角，所以选择左上角的这种固定方式。

再次进入游戏，Text的位置就不会变啦！

### 代码

接下来我们要将Numbers的值对应到Score变量：

声明一个Text变量，`public Text CherryNumber;`

回到Unity将Numbers的Text拖过去

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211030134644233.png" alt="image-20211030134644233" style="zoom:67%;" />

```c#
	//收集物品
    private void OnTriggerEnter2D(Collider2D collision)
    {
        if (collision.tag == "Collection")
        {
            Destroy(collision.gameObject);
            score++;
            //将int型变量转换成String
            CherryNumber.text = score.ToString();
        }
    }
```

## Session13：Enemy敌人

这节课我们来将敌人创建到场景中，具体的操作前面都学过了，这里再回顾一下：

首先创建一个2D的Sprite，然后将敌人的贴图拖进去，然后添加一个Animator组件，创建Animator Controller，在Animation窗口创建动画，调整Samples。

添加collider 2D组件，然后在Player Controller添加代码：

```c#
	private void OnCollisionEnter2D(Collision2D collision)
    {
        //下落时碰到敌人将其消灭
        if(animator.GetBool("falling"))
        {
            if (collision.gameObject.tag == "Enemy")
            {
                Destroy(collision.gameObject);
            }
        }
    }
```

## Session14：受伤效果Hurt

首先为人物添加一个hurt动画，然后添加过渡条件：

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211030184722918.png" alt="image-20211030184722918" style="zoom:67%;" />

新增一个hurting参数，用于判断受伤状态

写代码：

```C#
	//切换动画效果
    void SwitchAnimation()
    {
        //正在跳跃
        if (animator.GetBool("jumping"))
        {
            Debug.Log(rb.velocity.y);
            //y轴速度消失，开始下落
            if(rb.velocity.y <= 0)
            {
                animator.SetBool("jumping", false);
                animator.SetBool("falling", true);
            }
        }else if (isHurt)
        {
            animator.SetBool("hurting", true);
            if (Mathf.Abs(rb.velocity.x) < 0.2f)
            {
                animator.SetBool("hurting", false);
                isHurt = false;
            }
        }
        else if (coll.IsTouchingLayers(ground))
        {
            animator.SetBool("falling", false);
        }
    }

	
	private void OnCollisionEnter2D(Collision2D collision)
    {
        //碰到敌人时
        if (collision.gameObject.tag == "Enemy")
        {
            if (animator.GetBool("falling"))
            {
                Destroy(collision.gameObject);
            }
            else if(transform.position.x < collision.gameObject.transform.position.x)
            {
                isHurt = true;
                rb.velocity = new Vector2(-10, rb.velocity.y);
            }
            else if(transform.position.x > collision.gameObject.transform.position.x)
            {
                isHurt = true;
                rb.velocity = new Vector2(10, rb.velocity.y);
            }
        }
    }
```

这样写了之后可能发现碰到敌人后人物并不会被弹开，这是因为movement在一直在执行，所以需要更改Movement的作用条件

```c#
	void Update()
    {
        if(!isHurt)
        {
            Movement();
        }
        SwitchAnimation();
    }
```

isHurt是一个bool类型的变量，默认值为false，只有isHurt为false时人物才可以移动，当碰到敌人时，isHurt变为true，人物无法移动。

## Session15：AI敌人移动

为敌人添加一个移动效果，通过添加左右的子object来设定移动的距离：

![image-20211103191929356](https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211103191929356.png)

```c#
public class Enemy_Frog : MonoBehaviour
{
    public Rigidbody2D rb;
    public Transform leftpoint, rightpoint;
    public float speed;
    //控制转向，默认向左
    private bool faceLeft = true;
    private float leftx, rightx;
    
    // Start is called before the first frame update
    void Start()
    {
        rb = GetComponent<Rigidbody2D>();
        transform.DetachChildren();
        //获取子物体坐标
        leftx = leftpoint.position.x;
        rightx = rightpoint.position.x;
        //销毁子物体
        Destroy(leftpoint.gameObject);
        Destroy(rightpoint.gameObject);
    }

    // Update is called once per frame
    void Update()
    {
        Movement();
    }

    void Movement()
    {
        if(faceLeft)
        {
            rb.velocity = new Vector2(-speed, rb.velocity.y);
            if(transform.position.x < leftx)
            {
                transform.localScale = new Vector3(-1, 1, 1);
                faceLeft = false;
            }
        }
        else
        {
            rb.velocity = new Vector2(speed, rb.velocity.y);
            if(transform.position.x > rightx)
            {
                transform.localScale = new Vector3(1, 1, 1);
                faceLeft = true;
            }
        }
        
    }
}
```

设置好这些之后，将敌人变成预制体，放到场景中，就可以分别调整每一个敌人各自子物体的位置来调整各自的移动范围。

## Session16：Animation Events动画事件

### 解决问题

首先有一个问题，就是人物从高处下落的时候不是falling动画，我们需要在 `SwitchAnimation()` 里添加以下语句

```c#
		if(rb.velocity.y < 0.1f && !coll.IsTouchingLayers(ground))
        {
            animator.SetBool("falling", true);
        }
```

只要人物没有接触地面并且y轴速度小于0.1，就切换为falling动画

### Animation Event

依旧仿照之前的方法，为青蛙创建idle和jump的动画效果，并创建状态机的转换，设置过渡条件

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211103192106124.png" alt="image-20211103192106124" style="zoom:67%;" />

添加代码：

```c#
	private Animator animator;

	void Movement()
    {
        if(faceLeft)
        {
            if(coll.IsTouchingLayers(ground))
            {
                animator.SetBool("jumping", true);
                rb.velocity = new Vector2(-speed, jumpSpeed);
            }
                
            if(transform.position.x < leftx)
            {
                transform.localScale = new Vector3(-1, 1, 1);
                faceLeft = false;
            }
        }
        else
        {
            if (coll.IsTouchingLayers(ground))
            {
                animator.SetBool("jumping", true);
                rb.velocity = new Vector2(speed, jumpSpeed);
            }

            if (transform.position.x > rightx)
            {
                transform.localScale = new Vector3(1, 1, 1);
                faceLeft = true;
            }
        }
        
    }
```

相较于之前的改动是：

因为青蛙要跳动，所以要添加一个y轴方向的速度。



但这样写青蛙一直接触地面，就会一直处于jumping的状态，没法回到idle，所以我们需要新的方法来解决这个问题，让每次跳完都回到idle状态，我们需要用到Aniamtion Event，在Animation界面可以找到，点击add event，右边就会出现一个小东西

![image-20211103192158419](https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211103192158419.png)



我们可以挪动event的位置，并可在右侧设置想要执行的函数，我们想要执行Movement()，把它添加进去

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211103192219976.png" alt="image-20211103192219976" style="zoom:67%;" />



这样青蛙每一次执行了idle的动画之后，就会自动调用Movement()函数，进行一次jump。



最后添加一个切换动画的函数：

```c#
	void SwitchAnimator()
    {
        if (animator.GetBool("jumping"))
        {
            if(rb.velocity.y < 0.1f)
            {
                animator.SetBool("jumping", false);
                animator.SetBool("falling", true);
            }
        }
        if (coll.IsTouchingLayers(ground) && animator.GetBool("falling") )
        {
            animator.SetBool("falling", false);
        }
    }
```

在Update()里调用就可以了。



## Session17：消灭敌人的效果

### 制作老鹰

首先我们为游戏再添加一个敌人————老鹰，创建的方式和之前相同，这里只贴一下代码部分：

```c#
public class Enemy_Eagle : MonoBehaviour
{
    private Rigidbody2D rb;
    private Collider2D coll;
    private Animator anim;

    public Transform top, bottom;
    public float speed;

    private float topY, bottomY;
    private bool moveUp = true;
    
    // Start is called before the first frame update
    void Start()
    {
        rb = GetComponent<Rigidbody2D>();
        coll = GetComponent<Collider2D>();
        anim = GetComponent<Animator>();

        transform.DetachChildren();
        topY = top.position.y;
        bottomY = bottom.position.y;
        Destroy(top.gameObject);
        Destroy(bottom.gameObject);
    }

    // Update is called once per frame
    void Update()
    {
        Movement();
    }
    void Movement()
    {
        if(moveUp)
        {
            rb.velocity = new Vector2(rb.velocity.x, speed);
            if (transform.position.y > topY)
                moveUp = false;
        }
        else
        {
            rb.velocity = new Vector2(rb.velocity.x, -speed);
            if (transform.position.y < bottomY)
                moveUp = true;
        }
    }
}
```

和青蛙不同的就是青蛙是左右跳，而老鹰是上下飞的。

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211103192947306.png" alt="image-20211103192947306" style="zoom:67%;" />

### 敌人死亡效果

下面我们就来制作敌人被消灭的效果



首先依然是添加动画：

![image-20211103193253012](https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211103193253012.png)



设置状态机过渡

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211103193344373.png" alt="image-20211103193344373" style="zoom:80%;" />

这里要用到一个新的参数:trigger，一旦触发就执行death

![image-20211103193439186](https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211103193439186.png)

然后写代码：

我们要在主角下落踩到敌人的时候触发death动画，也就是要在PlayerController里调用Enemy_Frog的函数，所以需要创建一个Enemy_Frog的实例：

```c#
	private void OnCollisionEnter2D(Collision2D collision)
    {
        //碰到敌人时
        if (collision.gameObject.tag == "Enemy")
        {
            //创建Frog实例
            Enemy_Frog frog = collision.gameObject.GetComponent<Enemy_Frog>();
            if (animator.GetBool("falling"))
            {
                //这里将原先销毁碰撞体改成了调用frog的函数
                frog.JumpOn();
                rb.velocity = new Vector2(rb.velocity.x, 5);
            }
            else if(transform.position.x < collision.gameObject.transform.position.x)
            {
                isHurt = true;
                rb.velocity = new Vector2(-10, rb.velocity.y);
            }
            else if(transform.position.x > collision.gameObject.transform.position.x)
            {
                isHurt = true;
                rb.velocity = new Vector2(10, rb.velocity.y);
            }
        }
    }
```

然后在Enemy_Frog里加入函数

```c#
	void Death()
    {
        Destroy(gameObject);
    }

    public void JumpOn()
    {
        animator.SetTrigger("death");
    }
```

将`Death()`设为death的event

![image-20211103194435666](https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211103194435666.png)



![image-20211103194448786](https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211103194448786.png)



当主角踩到frog时，先触发death的动画，然后再执行`Death()`销毁物体。



这样可以完成单个敌人的死亡效果，但是每多一种敌人的类型，就要重新写了，其实我们可以创建一个Enemy的父类，让所有的敌人都继承它

```c#
public class Enemy : MonoBehaviour
{
    //protected 子类和父类共享
    protected Animator animator;

    protected virtual void Start()
    {
        animator = GetComponent<Animator>();
    }
    void Death()
    {
        Destroy(gameObject);
    }

    public void JumpOn()
    {
        animator.SetTrigger("death");
    }
}
```

然后在子类的Start中调用父类的Start

```C#
	protected override void Start()
    {
        base.Start();
        rb = GetComponent<Rigidbody2D>();

        transform.DetachChildren();
        topY = top.position.y;
        bottomY = bottom.position.y;
        Destroy(top.gameObject);
        Destroy(bottom.gameObject);
    }
```

PlayerController的代码也就改成了：

```c#
	private void OnCollisionEnter2D(Collision2D collision)
    {
        //碰到敌人时
        if (collision.gameObject.tag == "Enemy")
        {
            Enemy enemy = collision.gameObject.GetComponent<Enemy>();
            if (animator.GetBool("falling"))
            {
                enemy.JumpOn();
                rb.velocity = new Vector2(rb.velocity.x, 5);
            }
            else if(transform.position.x < collision.gameObject.transform.position.x)
            {
                isHurt = true;
                rb.velocity = new Vector2(-10, rb.velocity.y);
            }
            else if(transform.position.x > collision.gameObject.transform.position.x)
            {
                isHurt = true;
                rb.velocity = new Vector2(10, rb.velocity.y);
            }
        }
    }
```

## Session18：音效Audio

首先去素材商店下载，然后导入Unity。

### 添加bgm

为Player添加组件 Audio source，这里有一个小技巧：

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211103204706867.png" alt="image-20211103204706867" style="zoom:67%;" />

左边这些蓝色的部分表示更改只应用于当前的物体，因为Player是个prefabs，如果想要应用到所有的prefabs，可以点击右上角的overrides，选择Apply All

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211103204835842.png" alt="image-20211103204835842" style="zoom:67%;" />

这里我们先不管他，将喜欢的音频拖到AudioClip上，并且勾选Loop，让bgm循环播放

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211103205320690.png" alt="image-20211103205320690" style="zoom:67%;" />

### 添加各种音效

接着我们为敌人添加死亡音效，选择一个喜欢的音效，拖到敌人的AudioSource组件的AudioClip，不需要选择loop和play on awake

代码如下：

```c#
public class Enemy : MonoBehaviour
{
    //protected 子类和父类共享
    protected Animator animator;
    protected AudioSource deathAudio;

    protected virtual void Start()
    {
        animator = GetComponent<Animator>();
        deathAudio = GetComponent<AudioSource>();
    }
    void Death()
    {
        Destroy(gameObject);
    }

    public void JumpOn()
    {
        animator.SetTrigger("death");
        deathAudio.Play();
    }
}
```

这里又有一个小技巧，组件是可以复制的，点击一个组件右上角的三个点，进行copy

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211103211021717.png" alt="image-20211103211021717" style="zoom:67%;" />

然后随便选中另一个物体的某一个组件，paste

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211103211152545.png" alt="image-20211103211152545" style="zoom:67%;" />

这样就实现了组件的复制。



接下来我们再为人物添加其他音效，方法都是一样的，就是为先为人物添加Audio Source组件，然后将音频拖上去，配置音频属性，在人物的脚本里声明AudioSource，在适当的时候调用就可以了。

## Session19：对话框Dialog

### 添加对话框UI

在之前的UI下新建一个Panel，调整颜色为半透明的黑色，然后再在Panel下新建一个Text，锚点设为屏幕正下方，调整字体大小颜色

![image-20211104111501294](https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211104111501294.png)



### 代码实现Dialog的开关

我们希望主角在碰到门的时候弹出对话框，所以我们要为门添加一个collider，这里有两种做法：一种是直接为house添加collider，另一种是为house添加一个子物体，为子物体添加collider。我选择第二种，感觉更合理一些。



![image-20211104112500178](https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211104112500178.png)



勾选is trigger，因为我们不需要碰撞效果。

然后为其添加代码逻辑：

```c#
public class EnterDialog : MonoBehaviour
{
    public GameObject enterDialog;

    private void OnTriggerEnter2D(Collision2D collision)
    {
        if(collision.gameObject.tag == "Player")
        {
            enterDialog.SetActive(true);
        }
    }

    private void OnTriggerExit2D(Collider2D collision)
    {
        if (collision.gameObject.tag == "Player")
        {
            enterDialog.SetActive(false);
        }
    }
}
```

并把主角的tag设为Player，将刚才创建的Panel拖到脚本上。

### 录制动画

我们还想为Dialog添加一个渐入的效果，这个动画可以直接在Unity里面录制。

创建一个Animation，直接将其拖到Panel上，它会自动创建一个Animator组件和一个Animation Controller。

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211104114451206.png" alt="image-20211104114451206" style="zoom:67%;" />

点击录制：

![image-20211104115202774](https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211104115202774.png)

然后在固定帧更改Dialog的效果，即可。

## Session20：趴下效果Crouch

这节课我们来为主角添加趴下的效果



打开Project Setting -> Input Manager，我们发现Unity并没有内置的下蹲按键，所以我们需要添加一个，可以选中Jump，右键点击Duplicate，复制一个Input按键出来，改名为Crouch，并更改按键。

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211104155142145.png" alt="image-20211104155142145" style="zoom:67%;" />

我们可以使用这种方法添加任意自己想要的按键效果。

然后就可以为角色添加动画和代码了，动画部分略过，代码如下

```c#
	void Crouch()
    {
        if(Input.GetButtonDown("Crouch"))
        {
            animator.SetBool("crouching", true);
        }else if(Input.GetButtonUp("Crouch"))
        {
            animator.SetBool("crouching", false);
        }
    }
```

添加动画和代码之后，我们的角色可以下蹲了，但仍然无法穿过这样的物体：

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211104160852014.png" alt="image-20211104160852014" style="zoom:67%;" />



这是因为角色的碰撞体没有改变，这里我们采用的解决方法是当角色下蹲时取消头顶的方形collider

代码中添加：

```c#
	public Collider2D Discoll;

	void Crouch()
    {
        if(Input.GetButtonDown("Crouch"))
        {
            //按键按下
            animator.SetBool("crouching", true);
            Discoll.enabled = false;
        }else if(Input.GetButtonUp("Crouch"))
        {
            //按键抬起
            animator.SetBool("crouching", false);
            Discoll.enabled = true;
        }
    }
```

回到Unity，将box collider拖过去，这样就可以穿过去了，但这样还有个问题，就是如果在中间取消下蹲，人物回到idle之后会卡住

<img src="https://image-ym.oss-cn-guangzhou.aliyuncs.com/img/image-20211104161732643.png" alt="image-20211104161732643" style="zoom:67%;" />



所以我们需要更改一下代码逻辑：当角色头顶没有属于Ground图层的物体时才可以回到idle。

```c#
	//检测用的
	private bool checkHead = false;	

	private void Crouch()
    {
        if (Input.GetButtonDown("Crouch"))
        {
            animator.SetBool("crouching", true);
            //关闭box collider
            Discoll.enabled = false;
        }
        else if (Input.GetButtonUp("Crouch"))
        {
            //开启检测
            checkHead = true;
        }
        //检测头部是否有ground
        if(checkHead)
        {
            //overlap是重叠的意思，这个函数的作用是检查是否有碰撞体进入了指定的圆形区域
            //当角色头顶没有ground的碰撞体时才可以恢复idle状态
            if (!Physics2D.OverlapCircle(ceilingCheck.position, 0.2f, ground))
            {
                animator.SetBool("crouching", false);
                Discoll.enabled = true;
                //关闭检测
                checkHead = false;
            }
        }
        
    }
```

当松下下蹲的按键时，会开启检测，检测内容就是头顶有没有ground，没有的话就可以站起来回到idle。

## Session21：场景控制SceneManager

